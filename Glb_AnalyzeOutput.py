# -*- coding: utf-8 -*-
"""
A program to read and apply costs from a completed simulation. 

The program reads in unit costs from an Excel file and applies them to each instance
of the resource from the ResourceList array output from the Sequencer. It returns a
list of discounted costs

@author: icromwell
"""
############################################################################################
# Load some necessary packages and functions

from openpyxl import load_workbook                  # Load the import function
import numpy
import math
import random
import simpy

"Import values from the table"

from Glb_Estimates import Estimates
from Glb_Estimates import Estimate# Load data from the Excel spreadsheet

"""
from openpyxl import load_workbook
workbook = load_workbook('InputParameters.xlsx')
costsheet = workbook["Costs"]
cost_estimates = Estimates()
for line in costsheet.rows:
        if not line[0].value:
            # There's no estimate name in this row.
            continue
        setattr(cost_estimates, line[0].value, Estimate(line[1].value, line[2].value, line[3].value))
    del(cost_estimates.Parameter)
"""

##################################################################################################

# Load in the resource utilization list from the model run
from Glb_Estimates import Estimates
from Glb_Estimates import Estimate

class Analyze_Output:
    def __init__(self, estimates, costdict):
        self._estimates = estimates
        self._CostDict = costdict

    def CostEst(self, unit):
        """A function to estimate the unit cost from a mean and standard error"""
        # Fee-for-service and other fixed-value resources have a unit cost equal to the mean
        if self._CostDict[unit][0] == 1:
            samp_value = self._CostDict[unit][1]
        
        # Other kinds of costs are sampled from a gamma distribution based on their mean and sd
        elif self._CostDict[unit][0] == 2:
            x = self._CostDict[unit][1]
            y = self._CostDict[unit][2]
            gdist_shape = x**2/y**2                                    # A formula to produce the shape parameter
            gdist_scale = y**2/x                                       # A formula to produce the scale parameter
            samp_value = numpy.random.gamma(gdist_shape, gdist_scale)
            
        # Return an error if no variable type is specified
        else:
            print("Please specify a variable TypeNo for", unit, "in the parameter table")
            
        return samp_value

    def EntityCost(self, entity):
        """A function to calculate the costs experienced by each entity"""
        # Create a list with costs generated by each entity
        resourcelist = entity.resources
        maxlen = len(resourcelist)-1
        if maxlen < 0:
            pass
        else: 
            if resourcelist[maxlen][1] > entity.natHist_deathAge:
                del(resourcelist[maxlen])
        costList = []
        for j in range(0, len(resourcelist)):
            if resourcelist == []:   # If no costs have been generated
                costlist.append(0)
            else:
                for i in range((len(resourcelist[j])-1)):
                    unit = resourcelist[j][i]
                    # Years elapsed for the discounting function
                    year = float(resourcelist[j][1]/365)     
                    # Apply a discount rate for future costs
                    discRate_cost = 1 / (1 + self._CostDict['Discount'][1])**year              
                    costList.append(self.CostEst(unit)*discRate_cost)
        return sum(costList)
    
    def EntitySurvival(self, entity):
        """A function to calculate LYG and QALY for each entity"""
        # Load the entity's utility list from the model output
        ent_util = []
        for i in range(len(entity.utility)):
            ent_util.append([int(round(entity.utility[i][2], 0)), entity.utility[i][1]])
        # If entity has multiple utility values at t0, use only the last one
        if ent_util[len(ent_util)-1][0] == 0:
            # It's possible for an entity to live less than a day. We round up to 1 day just so the
            #   math doesn't crap out on us
            ent_util.append([1,0])
        while ent_util[1][0] == 0:
            del(ent_util[0])
        testset = []
        
        # This is a kludge to remove circumstances where an entity has multiple utility values
        #   as they persist in a single state. This finds duplicate sequential utility states
        #   (i.e., in 'Post-treatment Followup' multiple times in a row) and preserves only
        #   the first one. This is more consistent with how probabilistic sampling is supposed
        #   to work in modeling theory. The 'better' way to do this is to fix the way "estimates"
        #   does probabilistic sampling, but it will work for now.
        for i in range(1,len(ent_util)):
            if ent_util[i][0] == ent_util[i-1][0]:
                ent_util[i] = 'Delete'
        while 'Delete' in ent_util:
            ent_util.remove('Delete')
            for i in range(1,len(ent_util)):
                if ent_util[i][0] == ent_util[i-1][0]:
                    ent_util[i] = 'Delete'

        # Define the daily discount rate
        discountrate = self._estimates.DiscountRate.mean
        disc_rate = 1 - (1 - discountrate)**(1 / 365)
        
        day = 0
        LYG = 0
        QALY = 0
        # For each row in the survival/utility list 'ent_util'
        for h in (1,len(ent_util)-1):
            # The utility value is read from the second column
            Util = ent_util[h-1][1]
            # Each day and quality-adjusted day is discounted at a daily rate
            while day < ent_util[h][0]:
                LYG += (1/365)*(1+disc_rate)**(-day)
                QALY += (Util/365)*(1+disc_rate)**(-day)
                day +=1
        
        return [LYG, QALY]

